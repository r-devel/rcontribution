[
    {
        "subtype": "bot_message",
        "text": "*[Bug 18654] xyTable fails when both x and y are NA*\n<https:\/\/bugs.r-project.org\/show_bug.cgi?id=18654>\n\nHeather Turner (<mailto:ht@heatherturner.net|ht@heatherturner.net>) changed:\n\n           What    |Removed                     |Added\n----------------------------------------------------------------------------\n   Attachment #3291|0                           |1\n        is obsolete|                            |\n\n--- Comment #5 from Heather Turner (<mailto:ht@heatherturner.net|ht@heatherturner.net>) ---\nCreated attachment 3292\n  --&gt; <https:\/\/bugs.r-project.org\/attachment.cgi?id=3292&amp;action=edit>\nimprove runtime\n\nUpdated patch to give runtime more comparable to original version:\n\nxyTable: original\nxyTable1: patch using duplicated()\nxyTable2: patch adapting original code to account for NAs\n\n```\nlibrary(bench)\ny &lt;- rnorm(10000)\nx &lt;- rnorm(10000)\nres &lt;- bench::mark(xyTable(x, y), xyTable1(x, y), xyTable2(x, y))\nres[,1:9]\n#&gt; # A tibble: 3 x 9\n#&gt;   expression          min   median `itr\/sec` mem_alloc `gc\/sec` n_itr  n_gc\ntotal_time\n#&gt;   &lt;bch:expr&gt;     &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; \n &lt;bch:tm&gt;\n#&gt; 1 xyTable(x, y)    1.02ms   1.13ms     879.     2.02MB     38.9   339    15 \n    386ms\n#&gt; 2 xyTable1(x, y)  14.86ms  15.51ms      64.3    1.92MB     60.0    15    14 \n    233ms\n#&gt; 3 xyTable2(x, y)   1.19ms   1.31ms     765.      2.9MB     48.8   298    19 \n    390ms\n```\n\nAlso a simpler test case to cover all possible comparisons among ordered\nco-ordinates:\n\n```\nx &lt;- c(0.1, 0.1, 0.1, 0.2, 0.3, 0.4, 0.5, NA, NA)\ny &lt;- c(0.1, 0.2, NA, 0.2, 0.3, NA, NA, 0.1, NA)\nn &lt;- length(x)\nx &lt;- rep(x, each = n)\ny &lt;- rep(y, each = n)\nidentical(xyTable(x, y)$number, rep(9L, 9))\n```",
        "username": "r-bugs notifier",
        "icons": {
            "emoji": ":robot_face:"
        },
        "type": "message",
        "ts": "1705663043.660069",
        "bot_id": "B06769YJX9Q",
        "app_id": "A024R9PQM",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "iYhJh",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "[Bug 18654] xyTable fails when both x and y are NA",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "\n"
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/bugs.r-project.org\/show_bug.cgi?id=18654"
                            },
                            {
                                "type": "text",
                                "text": "\n\nHeather Turner ("
                            },
                            {
                                "type": "link",
                                "url": "mailto:ht@heatherturner.net",
                                "text": "ht@heatherturner.net"
                            },
                            {
                                "type": "text",
                                "text": ") changed:\n\n           What    |Removed                     |Added\n----------------------------------------------------------------------------\n   Attachment #3291|0                           |1\n        is obsolete|                            |\n\n--- Comment #5 from Heather Turner ("
                            },
                            {
                                "type": "link",
                                "url": "mailto:ht@heatherturner.net",
                                "text": "ht@heatherturner.net"
                            },
                            {
                                "type": "text",
                                "text": ") ---\nCreated attachment 3292\n  --> "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/bugs.r-project.org\/attachment.cgi?id=3292&amp;action=edit",
                                "text": "https:\/\/bugs.r-project.org\/attachment.cgi?id=3292&action=edit"
                            },
                            {
                                "type": "text",
                                "text": "\nimprove runtime\n\nUpdated patch to give runtime more comparable to original version:\n\nxyTable: original\nxyTable1: patch using duplicated()\nxyTable2: patch adapting original code to account for NAs\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_preformatted",
                        "elements": [
                            {
                                "type": "text",
                                "text": "library(bench)\ny <- rnorm(10000)\nx <- rnorm(10000)\nres <- bench::mark(xyTable(x, y), xyTable1(x, y), xyTable2(x, y))\nres[,1:9]\n#> # A tibble: 3 x 9\n#>   expression          min   median `itr\/sec` mem_alloc `gc\/sec` n_itr  n_gc\ntotal_time\n#>   <bch:expr>     <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl> <int> <dbl> \n <bch:tm>\n#> 1 xyTable(x, y)    1.02ms   1.13ms     879.     2.02MB     38.9   339    15 \n    386ms\n#> 2 xyTable1(x, y)  14.86ms  15.51ms      64.3    1.92MB     60.0    15    14 \n    233ms\n#> 3 xyTable2(x, y)   1.19ms   1.31ms     765.      2.9MB     48.8   298    19 \n    390ms\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\n\nAlso a simpler test case to cover all possible comparisons among ordered\nco-ordinates:\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_preformatted",
                        "elements": [
                            {
                                "type": "text",
                                "text": "x <- c(0.1, 0.1, 0.1, 0.2, 0.3, 0.4, 0.5, NA, NA)\ny <- c(0.1, 0.2, NA, 0.2, 0.3, NA, NA, 0.1, NA)\nn <- length(x)\nx <- rep(x, each = n)\ny <- rep(y, each = n)\nidentical(xyTable(x, y)$number, rep(9L, 9))\n"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "subtype": "bot_message",
        "text": "*[Bug 18655] Enhancements to `*wilcox` functions for large population sizes*\n<https:\/\/bugs.r-project.org\/show_bug.cgi?id=18655>\n\nIvan Krylov (<mailto:ikrylov@disroot.org|ikrylov@disroot.org>) changed:\n\n           What    |Removed                     |Added\n----------------------------------------------------------------------------\n   Attachment #3288|0                           |1\n        is obsolete|                            |\n\n--- Comment #10 from Ivan Krylov (<mailto:ikrylov@disroot.org|ikrylov@disroot.org>) ---\nCreated attachment 3293\n  --&gt; <https:\/\/bugs.r-project.org\/attachment.cgi?id=3293&amp;action=edit>\nSVN Patch Diff v3\n\nRegenerated the patch from attachment 3290 using `patch -p0 ... &amp;&amp; svn diff\n...` with no new changes. Something could have happened with the newlines in\n`src\/nmath\/wilcox.c` when the patch was originally produced.",
        "username": "r-bugs notifier",
        "icons": {
            "emoji": ":robot_face:"
        },
        "type": "message",
        "ts": "1705665011.130839",
        "bot_id": "B06769YJX9Q",
        "app_id": "A024R9PQM",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "35f",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "[Bug 18655] Enhancements to ",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "*wilcox",
                                "style": {
                                    "bold": true,
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " functions for large population sizes",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "\n"
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/bugs.r-project.org\/show_bug.cgi?id=18655"
                            },
                            {
                                "type": "text",
                                "text": "\n\nIvan Krylov ("
                            },
                            {
                                "type": "link",
                                "url": "mailto:ikrylov@disroot.org",
                                "text": "ikrylov@disroot.org"
                            },
                            {
                                "type": "text",
                                "text": ") changed:\n\n           What    |Removed                     |Added\n----------------------------------------------------------------------------\n   Attachment #3288|0                           |1\n        is obsolete|                            |\n\n--- Comment #10 from Ivan Krylov ("
                            },
                            {
                                "type": "link",
                                "url": "mailto:ikrylov@disroot.org",
                                "text": "ikrylov@disroot.org"
                            },
                            {
                                "type": "text",
                                "text": ") ---\nCreated attachment 3293\n  --> "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/bugs.r-project.org\/attachment.cgi?id=3293&amp;action=edit",
                                "text": "https:\/\/bugs.r-project.org\/attachment.cgi?id=3293&action=edit"
                            },
                            {
                                "type": "text",
                                "text": "\nSVN Patch Diff v3\n\nRegenerated the patch from attachment 3290 using `patch -p0 ... && svn diff\n...` with no new changes. Something could have happened with the newlines in\n"
                            },
                            {
                                "type": "text",
                                "text": "src\/nmath\/wilcox.c",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " when the patch was originally produced."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "subtype": "bot_message",
        "text": "*[Bug 18655] Enhancements to `*wilcox` functions for large population sizes*\n<https:\/\/bugs.r-project.org\/show_bug.cgi?id=18655>\n\n--- Comment #11 from Aidan H Lakshman (<mailto:AHL27@pitt.edu|AHL27@pitt.edu>) ---\n(In reply to Ivan Krylov from comment #10)\nThanks Ivan, you're a lifesaver!",
        "username": "r-bugs notifier",
        "icons": {
            "emoji": ":robot_face:"
        },
        "type": "message",
        "ts": "1705676611.020139",
        "bot_id": "B06769YJX9Q",
        "app_id": "A024R9PQM",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "bL5\/",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "[Bug 18655] Enhancements to ",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "*wilcox",
                                "style": {
                                    "bold": true,
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " functions for large population sizes",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "\n"
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/bugs.r-project.org\/show_bug.cgi?id=18655"
                            },
                            {
                                "type": "text",
                                "text": "\n\n--- Comment #11 from Aidan H Lakshman ("
                            },
                            {
                                "type": "link",
                                "url": "mailto:AHL27@pitt.edu",
                                "text": "AHL27@pitt.edu"
                            },
                            {
                                "type": "text",
                                "text": ") ---\n(In reply to Ivan Krylov from comment #10)\nThanks Ivan, you're a lifesaver!"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "subtype": "bot_message",
        "text": "*[Bug 18657] New: Stack overflow from ReadRDS*\n<https:\/\/bugs.r-project.org\/show_bug.cgi?id=18657>\n\n            Bug ID: 18657\n           Summary: Stack overflow from ReadRDS\n           Product: R\n           Version: R 4.3.x\n          Hardware: x86_64\/x64\/amd64 (64-bit)\n                OS: Linux\n            Status: UNCONFIRMED\n          Severity: enhancement\n          Priority: P5\n         Component: Low-level\n          Assignee: <mailto:R-core@R-project.org|R-core@R-project.org>\n          Reporter: <mailto:aidan.dakhama@kcl.ac.uk|aidan.dakhama@kcl.ac.uk>\n\nCreated attachment 3294\n  --&gt; <https:\/\/bugs.r-project.org\/attachment.cgi?id=3294&amp;action=edit>\nInput file which causes the crash\n\nWhen running ReadRDS on certain inputs, ReadRDS causes a segmentation fault.\nThe expected behaviour is to raise an exception.\n\nThe code to reproduce the error is:\n```\nparams &lt;- readRDS(\"input-1\")\n```\nWhere input-1 has been attached. \n\nThis can be run with `Rscript bug.R` in the same folder as the input file.\n\n\n```\nR.Version\n\nplatform       x86_64-pc-linux-gnu         \narch           x86_64                      \nos             linux-gnu                   \nsystem         x86_64, linux-gnu           \nstatus                                     \nmajor          4                           \nminor          3.2                         \nyear           2023                        \nmonth          10                          \nday            31                          \nsvn rev        85441                       \nlanguage       R                           \nversion.string R version 4.3.2 (2023-10-31)\nnickname       Eye Holes \n```\n\nIt also occurs on older versions of R (tested on 4.2.3 and 4.1.3).\n\nThe error produced with address sanatizer is: \n\n```\n *** caught segfault ***\naddress 0x7ffe4bdae918, cause 'memory not mapped'\n\nTraceback:\n 1: readRDS(\"input-1\")\nAn irrecoverable exception occurred. R is aborting now ...\nSegmentation fault (core dumped)\n```\n\nThis is also reported as an exploitable vulnerability when tested with\nexploitable:\n\n```\nDescription: Possible stack corruption\nShort description: PossibleStackCorruption (7\/22)\nHash: 52bfa42eea51f9b4169f658421c15d8e.51f8e0011a8961b62115b84f44b92afd\nExploitability Classification: EXPLOITABLE\nExplanation: GDB generated an error while unwinding the stack and\/or the stack\ncontained return addresses that were not mapped in the inferior's process\naddress space and\/or the stack pointer is pointing to a location outside the\ndefault stack region. These conditions likely indicate stack corruption, which\nis generally considered exploitable.\nOther tags: DestAv (8\/22), AccessViolation (21\/22)\n```\n\nThis is likely a repeat of a previously reported bug 17578, which was closed.",
        "username": "r-bugs notifier",
        "icons": {
            "emoji": ":robot_face:"
        },
        "type": "message",
        "ts": "1705678257.700309",
        "bot_id": "B06769YJX9Q",
        "app_id": "A024R9PQM",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "a\/qKF",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "[Bug 18657] New: Stack overflow from ReadRDS",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "\n"
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/bugs.r-project.org\/show_bug.cgi?id=18657"
                            },
                            {
                                "type": "text",
                                "text": "\n\n            Bug ID: 18657\n           Summary: Stack overflow from ReadRDS\n           Product: R\n           Version: R 4.3.x\n          Hardware: x86_64\/x64\/amd64 (64-bit)\n                OS: Linux\n            Status: UNCONFIRMED\n          Severity: enhancement\n          Priority: P5\n         Component: Low-level\n          Assignee: "
                            },
                            {
                                "type": "link",
                                "url": "mailto:R-core@R-project.org",
                                "text": "R-core@R-project.org",
                                "unsafe": true
                            },
                            {
                                "type": "text",
                                "text": "\n          Reporter: "
                            },
                            {
                                "type": "link",
                                "url": "mailto:aidan.dakhama@kcl.ac.uk",
                                "text": "aidan.dakhama@kcl.ac.uk",
                                "unsafe": true
                            },
                            {
                                "type": "text",
                                "text": "\n\nCreated attachment 3294\n  --> "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/bugs.r-project.org\/attachment.cgi?id=3294&amp;action=edit",
                                "text": "https:\/\/bugs.r-project.org\/attachment.cgi?id=3294&action=edit"
                            },
                            {
                                "type": "text",
                                "text": "\nInput file which causes the crash\n\nWhen running ReadRDS on certain inputs, ReadRDS causes a segmentation fault.\nThe expected behaviour is to raise an exception.\n\nThe code to reproduce the error is:"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_preformatted",
                        "elements": [
                            {
                                "type": "text",
                                "text": "params <- readRDS(\"input-1\")\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Where input-1 has been attached. \n\nThis can be run with "
                            },
                            {
                                "type": "text",
                                "text": "Rscript bug.R",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " in the same folder as the input file.\n\n\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_preformatted",
                        "elements": [
                            {
                                "type": "text",
                                "text": "R.Version\n\nplatform       x86_64-pc-linux-gnu         \narch           x86_64                      \nos             linux-gnu                   \nsystem         x86_64, linux-gnu           \nstatus                                     \nmajor          4                           \nminor          3.2                         \nyear           2023                        \nmonth          10                          \nday            31                          \nsvn rev        85441                       \nlanguage       R                           \nversion.string R version 4.3.2 (2023-10-31)\nnickname       Eye Holes \n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\n\nIt also occurs on older versions of R (tested on 4.2.3 and 4.1.3).\n\nThe error produced with address sanatizer is: \n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_preformatted",
                        "elements": [
                            {
                                "type": "text",
                                "text": " *** caught segfault ***\naddress 0x7ffe4bdae918, cause 'memory not mapped'\n\nTraceback:\n 1: readRDS(\"input-1\")\nAn irrecoverable exception occurred. R is aborting now ...\nSegmentation fault (core dumped)\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\n\nThis is also reported as an exploitable vulnerability when tested with\nexploitable:\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_preformatted",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Description: Possible stack corruption\nShort description: PossibleStackCorruption (7\/22)\nHash: 52bfa42eea51f9b4169f658421c15d8e.51f8e0011a8961b62115b84f44b92afd\nExploitability Classification: EXPLOITABLE\nExplanation: GDB generated an error while unwinding the stack and\/or the stack\ncontained return addresses that were not mapped in the inferior's process\naddress space and\/or the stack pointer is pointing to a location outside the\ndefault stack region. These conditions likely indicate stack corruption, which\nis generally considered exploitable.\nOther tags: DestAv (8\/22), AccessViolation (21\/22)\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\n\nThis is likely a repeat of a previously reported bug 17578, which was closed."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "subtype": "bot_message",
        "text": "*[Bug 18655] Enhancements to `*wilcox` functions for large population sizes*\n<https:\/\/bugs.r-project.org\/show_bug.cgi?id=18655>\n\n--- Comment #12 from Andreas Löffler (<mailto:andreas.loeffler@gmail.com|andreas.loeffler@gmail.com>) ---\nIf I see this correctly, the function becomes slower for large numbers compared\nto the classic Wilcox because for an ongoing n, all divisors d must be\ndetermined and then these divisors are added (if they are between 1 and n1) or\nsubtracted (if they are between n2+1 and n2+n1). Maybe it can be programmed\ndifferently? \n\nFirst, one would define an array of length n that is supposed to contain the\nvalues of the sigma function. If we can determine all prime factors of n (and I\ndon't know if that is quick; I found nothing about it in 'Numerical Recipes'),\nthen we know all conceivable d for which n mod d=0. Then one would only need to\niterate over these divisors and would only check if the iterating d is between\n1 and n1+1 as well as n2+1 and n2+n1.\n\nHowever, it could be that this procedure becomes longer because firstly, we\nneed the prime factors and secondly, we must multiply very many numbers (namely\nthe prime factors). Unfortunately, I have too little experience for this.",
        "username": "r-bugs notifier",
        "icons": {
            "emoji": ":robot_face:"
        },
        "type": "message",
        "ts": "1705684167.818269",
        "bot_id": "B06769YJX9Q",
        "app_id": "A024R9PQM",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "mgPT",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "[Bug 18655] Enhancements to ",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "*wilcox",
                                "style": {
                                    "bold": true,
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " functions for large population sizes",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "\n"
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/bugs.r-project.org\/show_bug.cgi?id=18655"
                            },
                            {
                                "type": "text",
                                "text": "\n\n--- Comment #12 from Andreas Löffler ("
                            },
                            {
                                "type": "link",
                                "url": "mailto:andreas.loeffler@gmail.com",
                                "text": "andreas.loeffler@gmail.com"
                            },
                            {
                                "type": "text",
                                "text": ") ---\nIf I see this correctly, the function becomes slower for large numbers compared\nto the classic Wilcox because for an ongoing n, all divisors d must be\ndetermined and then these divisors are added (if they are between 1 and n1) or\nsubtracted (if they are between n2+1 and n2+n1). Maybe it can be programmed\ndifferently? \n\nFirst, one would define an array of length n that is supposed to contain the\nvalues of the sigma function. If we can determine all prime factors of n (and I\ndon't know if that is quick; I found nothing about it in 'Numerical Recipes'),\nthen we know all conceivable d for which n mod d=0. Then one would only need to\niterate over these divisors and would only check if the iterating d is between\n1 and n1+1 as well as n2+1 and n2+n1.\n\nHowever, it could be that this procedure becomes longer because firstly, we\nneed the prime factors and secondly, we must multiply very many numbers (namely\nthe prime factors). Unfortunately, I have too little experience for this."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "subtype": "bot_message",
        "text": "*[Bug 18655] Enhancements to `*wilcox` functions for large population sizes*\n<https:\/\/bugs.r-project.org\/show_bug.cgi?id=18655>\n\n--- Comment #13 from Aidan H Lakshman (<mailto:AHL27@pitt.edu|AHL27@pitt.edu>) ---\n(In reply to Andreas Löffler from comment #12)\n&gt; If I see this correctly, the function becomes slower for large numbers\n&gt; compared to the classic Wilcox because for an ongoing n, all divisors d must\n&gt; be determined and then these divisors are added (if they are between 1 and\n&gt; n1) or subtracted (if they are between n2+1 and n2+n1). Maybe it can be\n&gt; programmed differently? \n\nNot quite--this function is faster for large numbers compared to the classic\nWilcox. The only slow case is precisely when at least one population is less\nthan but very close to 50 (e.g., `qwilcox(q, n, m)` with one or more of `n,m`\nin the range `[40,50]`). If either population is size 51 or larger, the\nfunction runs significantly faster than the classic Wilcox.\n\n&gt; First, one would define an array of length n that is supposed to contain the\n&gt; values of the sigma function. If we can determine all prime factors of n\n&gt; (and I don't know if that is quick; I found nothing about it in 'Numerical\n&gt; Recipes'), then we know all conceivable d for which n mod d=0. Then one\n&gt; would only need to iterate over these divisors and would only check if the\n&gt; iterating d is between 1 and n1+1 as well as n2+1 and n2+n1.\n&gt; \n&gt; However, it could be that this procedure becomes longer because firstly, we\n&gt; need the prime factors and secondly, we must multiply very many numbers\n&gt; (namely the prime factors). Unfortunately, I have too little experience for\n&gt; this.\n\nThe slowdown is actually not primarily due to the factorization of `k`, it's\nmainly in the recursive formula that we calculate the distribution with (see\nIvan's comment above, specifically with regard to `s += w[i]*sigma[k-i];`). \n\nFactorizing integers is a notoriously challenging problem, and I'm not sure\nthat it would help significantly. Any time saved by reducing calls to `%` would\nlikely be significantly less than the cost incurred by additional division\ncalls necessary to derive factors from prime factors. My implementation only\nsearches the ranges `[1, min(m,k)]` and `[n+1, min(k,m+n)]`, so there is\ntheoretically a modest improvement possible in runtime when `k` has few prime\nfactors and `k,m,n &gt;&gt; 0`. \n\nThe most straightforward improvement would likely be saving a static lookup\ntable of the all primes less than `sqrt(MAX_INT\/2)`, since `m+n &lt;= MAX_INT`.\nUsing iterated division for primes less than `sqrt(k)` would allow the\noperation to be done in roughly `O(log k)` time, I think. For 32-bit signed\nintegers, this would be primes less than 32768, of which there are 1,000, so\nwe'd use around 4MB of space. However, this isn't a portable solution--we can't\nguarantee that `int` maps to a 32-bit number. Initializing an array of primes\non startup is also possible using a Sieve of Eratosthenes method, but this\nrisks increasing startup times by a lot and burning a lot of disk space.\n\nI'm cautious about these solutions. My concern is that we are likely\noverengineering the problem to shave relatively minor amounts of time,\nespecially since this call isn't dominating runtime. The cost of that would be\nsignificantly more complex code (and for the lookup table option, I'm not\nentirely convinced that dedicating 4MB of the 90MB in R purely to Wilcoxon\ntests is worth it). I am happy to look into those improvements, though, if\nR-core would be interested in seeing the runtime benefit.\n\nThe best place to look for improvements is in optimizing the recursive formula.\nDetermining the `k`'th member of the distribution has time complexity `O(k^2)`,\nwhich dominates the runtime for large population sizes (compared to complexity\n`O(k)` for factorizing `k`). I'm far from a C wizard, but I at least haven't\nbeen able to find any way to further optimize the code beyond what I've\n",
        "username": "r-bugs notifier",
        "icons": {
            "emoji": ":robot_face:"
        },
        "type": "message",
        "ts": "1705687550.483529",
        "bot_id": "B06769YJX9Q",
        "app_id": "A024R9PQM",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "T+yg",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "[Bug 18655] Enhancements to ",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "*wilcox",
                                "style": {
                                    "bold": true,
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " functions for large population sizes",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "\n"
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/bugs.r-project.org\/show_bug.cgi?id=18655"
                            },
                            {
                                "type": "text",
                                "text": "\n\n--- Comment #13 from Aidan H Lakshman ("
                            },
                            {
                                "type": "link",
                                "url": "mailto:AHL27@pitt.edu",
                                "text": "AHL27@pitt.edu"
                            },
                            {
                                "type": "text",
                                "text": ") ---\n(In reply to Andreas Löffler from comment #12)"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "If I see this correctly, the function becomes slower for large numbers\ncompared to the classic Wilcox because for an ongoing n, all divisors d must\nbe determined and then these divisors are added (if they are between 1 and\nn1) or subtracted (if they are between n2+1 and n2+n1). Maybe it can be\nprogrammed differently? "
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\n\nNot quite--this function is faster for large numbers compared to the classic\nWilcox. The only slow case is precisely when at least one population is less\nthan but very close to 50 (e.g., "
                            },
                            {
                                "type": "text",
                                "text": "qwilcox(q, n, m)",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " with one or more of "
                            },
                            {
                                "type": "text",
                                "text": "n,m",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "\nin the range "
                            },
                            {
                                "type": "text",
                                "text": "[40,50]",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "). If either population is size 51 or larger, the\nfunction runs significantly faster than the classic Wilcox.\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "First, one would define an array of length n that is supposed to contain the\nvalues of the sigma function. If we can determine all prime factors of n\n(and I don't know if that is quick; I found nothing about it in 'Numerical\nRecipes'), then we know all conceivable d for which n mod d=0. Then one\nwould only need to iterate over these divisors and would only check if the\niterating d is between 1 and n1+1 as well as n2+1 and n2+n1.\n\nHowever, it could be that this procedure becomes longer because firstly, we\nneed the prime factors and secondly, we must multiply very many numbers\n(namely the prime factors). Unfortunately, I have too little experience for\nthis."
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\n\nThe slowdown is actually not primarily due to the factorization of "
                            },
                            {
                                "type": "text",
                                "text": "k",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ", it's\nmainly in the recursive formula that we calculate the distribution with (see\nIvan's comment above, specifically with regard to "
                            },
                            {
                                "type": "text",
                                "text": "s += w[i]*sigma[k-i];",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "). \n\nFactorizing integers is a notoriously challenging problem, and I'm not sure\nthat it would help significantly. Any time saved by reducing calls to "
                            },
                            {
                                "type": "text",
                                "text": "%",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " would\nlikely be significantly less than the cost incurred by additional division\ncalls necessary to derive factors from prime factors. My implementation only\nsearches the ranges "
                            },
                            {
                                "type": "text",
                                "text": "[1, min(m,k)]",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " and "
                            },
                            {
                                "type": "text",
                                "text": "[n+1, min(k,m+n)]",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ", so there is\ntheoretically a modest improvement possible in runtime when "
                            },
                            {
                                "type": "text",
                                "text": "k",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " has few prime\nfactors and "
                            },
                            {
                                "type": "text",
                                "text": "k,m,n >> 0",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ". \n\nThe most straightforward improvement would likely be saving a static lookup\ntable of the all primes less than "
                            },
                            {
                                "type": "text",
                                "text": "sqrt(MAX_INT\/2)",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ", since "
                            },
                            {
                                "type": "text",
                                "text": "m+n <= MAX_INT",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ".\nUsing iterated division for primes less than "
                            },
                            {
                                "type": "text",
                                "text": "sqrt(k)",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " would allow the\noperation to be done in roughly "
                            },
                            {
                                "type": "text",
                                "text": "O(log k)",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " time, I think. For 32-bit signed\nintegers, this would be primes less than 32768, of which there are 1,000, so\nwe'd use around 4MB of space. However, this isn't a portable solution--we can't\nguarantee that "
                            },
                            {
                                "type": "text",
                                "text": "int",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " maps to a 32-bit number. Initializing an array of primes\non startup is also possible using a Sieve of Eratosthenes method, but this\nrisks increasing startup times by a lot and burning a lot of disk space.\n\nI'm cautious about these solutions. My concern is that we are likely\noverengineering the problem to shave relatively minor amounts of time,\nespecially since this call isn't dominating runtime. The cost of that would be\nsignificantly more complex code (and for the lookup table option, I'm not\nentirely convinced that dedicating 4MB of the 90MB in R purely to Wilcoxon\ntests is worth it). I am happy to look into those improvements, though, if\nR-core would be interested in seeing the runtime benefit.\n\nThe best place to look for improvements is in optimizing the recursive formula.\nDetermining the "
                            },
                            {
                                "type": "text",
                                "text": "k",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "'th member of the distribution has time complexity "
                            },
                            {
                                "type": "text",
                                "text": "O(k^2)",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ",\nwhich dominates the runtime for large population sizes (compared to complexity\n"
                            },
                            {
                                "type": "text",
                                "text": "O(k)",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " for factorizing "
                            },
                            {
                                "type": "text",
                                "text": "k",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "). I'm far from a C wizard, but I at least haven't\nbeen able to find any way to further optimize the code beyond what I've"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "subtype": "bot_message",
        "text": "presented here, aside from the possible cache locality optimization Ivan and I\nhave previously discussed. If there were a way to reduce the below nested loop\ninto a single loop, it would speed up runtime by a substantial amount:\n\n```\n    \/* fill in the values for the distribution *\/\n    for (k=max_k+1; k&lt;=new_k; k++){\n        if (k==0){\n            w[0]=1; \/* by definition 0 has only 1 partition *\/\n        } else {\n            s = 0;\n            \/* Somehow eliminating this loop would save a lot of time: *\/\n            for (i = 0; i&lt;k; i++){\n                \/* recursion formula *\/\n                s += w[i]*sigma[k-i];\n            }\n            w[k] = s\/k;\n        }\n    }\n```\n\nIt's also worth noting that, for small values of `m,n`, the max possible\nruntime improvement for refactoring the factorization formula is only 50%\n(according to Ivan's profiling). This would still result in the current version\nperforming much slower than the older version in the `m,n \\in [40,50]` regime.\n\nRegardless, as mentioned previously, I personally don't think the performance\npenalty of the new solution is large enough to warrant sticking to the old\nsolution. The cases in which the new version are noticeably slower than the old\nversion are narrow enough that it's probably worth it (in my opinion, though I\nam not R-core). My understanding is that that view is roughly in line with\nMartin's previous thoughts as well.",
        "username": "r-bugs notifier",
        "icons": {
            "emoji": ":robot_face:"
        },
        "type": "message",
        "ts": "1705687550.508469",
        "bot_id": "B06769YJX9Q",
        "app_id": "A024R9PQM",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "8v499",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "presented here, aside from the possible cache locality optimization Ivan and I\nhave previously discussed. If there were a way to reduce the below nested loop\ninto a single loop, it would speed up runtime by a substantial amount:\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_preformatted",
                        "elements": [
                            {
                                "type": "text",
                                "text": "    \/* fill in the values for the distribution *\/\n    for (k=max_k+1; k<=new_k; k++){\n        if (k==0){\n            w[0]=1; \/* by definition 0 has only 1 partition *\/\n        } else {\n            s = 0;\n            \/* Somehow eliminating this loop would save a lot of time: *\/\n            for (i = 0; i<k; i++){\n                \/* recursion formula *\/\n                s += w[i]*sigma[k-i];\n            }\n            w[k] = s\/k;\n        }\n    }\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\n\nIt's also worth noting that, for small values of "
                            },
                            {
                                "type": "text",
                                "text": "m,n",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ", the max possible\nruntime improvement for refactoring the factorization formula is only 50%\n(according to Ivan's profiling). This would still result in the current version\nperforming much slower than the older version in the "
                            },
                            {
                                "type": "text",
                                "text": "m,n \\in [40,50]",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " regime.\n\nRegardless, as mentioned previously, I personally don't think the performance\npenalty of the new solution is large enough to warrant sticking to the old\nsolution. The cases in which the new version are noticeably slower than the old\nversion are narrow enough that it's probably worth it (in my opinion, though I\nam not R-core). My understanding is that that view is roughly in line with\nMartin's previous thoughts as well."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "subtype": "bot_message",
        "text": "*[Bug 18657] Stack overflow from ReadRDS*\n<https:\/\/bugs.r-project.org\/show_bug.cgi?id=18657>\n\nIvan Krylov (<mailto:ikrylov@disroot.org|ikrylov@disroot.org>) changed:\n\n           What    |Removed                     |Added\n----------------------------------------------------------------------------\n                 CC|                            |ikrylov@disroot.org\n\n--- Comment #1 from Ivan Krylov (<mailto:ikrylov@disroot.org|ikrylov@disroot.org>) ---\nCreated attachment 3295\n  --&gt; <https:\/\/bugs.r-project.org\/attachment.cgi?id=3295&amp;action=edit>\nCheck stack space before allocating\n\nThis gzip-compressed file is corrupted. How was it produced? R is not designed\nto be a security boundary and should only be used with data coming from trusted\nsources.\n\nHaving said that, the crash is indeed unfortunate and comes from allocating a\nVLA with size determined by the serialized data stream. I think this is the\nlast unchecked VLA in `serialize.c`: all the other allocations are either\nconstant-sized or use the heap if the length exceeds a threshold.",
        "username": "r-bugs notifier",
        "icons": {
            "emoji": ":robot_face:"
        },
        "type": "message",
        "ts": "1705689367.654609",
        "bot_id": "B06769YJX9Q",
        "app_id": "A024R9PQM",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "IJ6",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "[Bug 18657] Stack overflow from ReadRDS",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "\n"
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/bugs.r-project.org\/show_bug.cgi?id=18657"
                            },
                            {
                                "type": "text",
                                "text": "\n\nIvan Krylov ("
                            },
                            {
                                "type": "link",
                                "url": "mailto:ikrylov@disroot.org",
                                "text": "ikrylov@disroot.org"
                            },
                            {
                                "type": "text",
                                "text": ") changed:\n\n           What    |Removed                     |Added\n----------------------------------------------------------------------------\n                 CC|                            |ikrylov@disroot.org\n\n--- Comment #1 from Ivan Krylov ("
                            },
                            {
                                "type": "link",
                                "url": "mailto:ikrylov@disroot.org",
                                "text": "ikrylov@disroot.org"
                            },
                            {
                                "type": "text",
                                "text": ") ---\nCreated attachment 3295\n  --> "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/bugs.r-project.org\/attachment.cgi?id=3295&amp;action=edit",
                                "text": "https:\/\/bugs.r-project.org\/attachment.cgi?id=3295&action=edit"
                            },
                            {
                                "type": "text",
                                "text": "\nCheck stack space before allocating\n\nThis gzip-compressed file is corrupted. How was it produced? R is not designed\nto be a security boundary and should only be used with data coming from trusted\nsources.\n\nHaving said that, the crash is indeed unfortunate and comes from allocating a\nVLA with size determined by the serialized data stream. I think this is the\nlast unchecked VLA in "
                            },
                            {
                                "type": "text",
                                "text": "serialize.c",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ": all the other allocations are either\nconstant-sized or use the heap if the length exceeds a threshold."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "subtype": "bot_message",
        "text": "*[Bug 18654] xyTable fails when both x and y are NA*\n<https:\/\/bugs.r-project.org\/show_bug.cgi?id=18654>\n\n--- Comment #6 from Elin Waring (<mailto:elin.waring@gmail.com|elin.waring@gmail.com>) ---\nNice!\n\n\nThe changed result gives the same values for `number` as you get with `table(x,\nuseNA = \"ifany\"), which could possibly be added to the documentation.",
        "username": "r-bugs notifier",
        "icons": {
            "emoji": ":robot_face:"
        },
        "type": "message",
        "ts": "1705710103.067369",
        "bot_id": "B06769YJX9Q",
        "app_id": "A024R9PQM",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "RsTgt",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "[Bug 18654] xyTable fails when both x and y are NA",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "\n"
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/bugs.r-project.org\/show_bug.cgi?id=18654"
                            },
                            {
                                "type": "text",
                                "text": "\n\n--- Comment #6 from Elin Waring ("
                            },
                            {
                                "type": "link",
                                "url": "mailto:elin.waring@gmail.com",
                                "text": "elin.waring@gmail.com"
                            },
                            {
                                "type": "text",
                                "text": ") ---\nNice!\n\n\n\nThe changed result gives the same values for "
                            },
                            {
                                "type": "text",
                                "text": "number",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " as you get with `table(x,\nuseNA = \"ifany\"), which could possibly be added to the documentation."
                            }
                        ]
                    }
                ]
            }
        ]
    }
]