[
    {
        "user": "U051AF92WSK",
        "type": "message",
        "ts": "1682326001.395379",
        "client_msg_id": "7e08d439-6028-4837-8bad-305d3622bbf7",
        "text": "<https:\/\/kbroman.org\/minimal_make\/|This> little tutorial on `make` is quite good. However, the actual R build is quite complex and require more knowledge of `make` to fully understand.",
        "team": "T01DW9DLB2A",
        "user_team": "T01DW9DLB2A",
        "source_team": "T01DW9DLB2A",
        "user_profile": {
            "avatar_hash": "ea006f787a6a",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-04-04\/5052497400406_ea006f787a6a30b5b361_72.png",
            "first_name": "Hieu",
            "real_name": "Hieu Nguyen",
            "display_name": "Hieu Nguyen",
            "team": "T01DW9DLB2A",
            "name": "hieuducnguyen012",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1682273441.848779",
        "parent_user_id": "U053BP20H8E",
        "attachments": [
            {
                "from_url": "https:\/\/kbroman.org\/minimal_make\/",
                "service_icon": "https:\/\/kbroman.org\/favicon.ico",
                "id": 1,
                "original_url": "https:\/\/kbroman.org\/minimal_make\/",
                "fallback": "minimal make",
                "text": "A minimal tutorial on GNU Make, the most important tool for reproducible research.",
                "title": "minimal make",
                "title_link": "https:\/\/kbroman.org\/minimal_make\/",
                "service_name": "kbroman.org"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "sxazB",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "link",
                                "url": "https:\/\/kbroman.org\/minimal_make\/",
                                "text": "This"
                            },
                            {
                                "type": "text",
                                "text": " little tutorial on "
                            },
                            {
                                "type": "text",
                                "text": "make",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " is quite good. However, the actual R build is quite complex and require more knowledge of "
                            },
                            {
                                "type": "text",
                                "text": "make",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " to fully understand."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U053BP20H8E",
        "type": "message",
        "ts": "1682335719.175089",
        "client_msg_id": "F03B8D93-5509-44FC-9066-746B51065958",
        "text": "Awesome thanks! Gotta start from somewhere haha ",
        "team": "T01DW9DLB2A",
        "user_team": "T01DW9DLB2A",
        "source_team": "T01DW9DLB2A",
        "user_profile": {
            "avatar_hash": "22b9a7da415c",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-04-17\/5113784112230_22b9a7da415c6d9b3e5c_72.png",
            "first_name": "Stone",
            "real_name": "Stone Chen",
            "display_name": "",
            "team": "T01DW9DLB2A",
            "name": "chen.stonechen",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1682273441.848779",
        "parent_user_id": "U053BP20H8E",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "8J2",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Awesome thanks! Gotta start from somewhere haha "
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U02B94YEKA5",
        "type": "message",
        "ts": "1682349306.623369",
        "client_msg_id": "aa9fb8ce-33ee-40ec-983c-71157faa4410",
        "text": "I learned from the Ihaka tutorial - <https:\/\/web.archive.org\/web\/20081018224543\/https:\/\/www.stat.auckland.ac.nz\/~stat782\/downloads\/make-tutorial.pdf>",
        "team": "T01DW9DLB2A",
        "user_team": "T01DW9DLB2A",
        "source_team": "T01DW9DLB2A",
        "user_profile": {
            "avatar_hash": "7a2d876d1cd9",
            "image_72": "https:\/\/avatars.slack-edge.com\/2021-08-11\/2394178193216_7a2d876d1cd953166d9c_72.jpg",
            "first_name": "Neal",
            "real_name": "Neal Fultz",
            "display_name": "Neal Fultz",
            "team": "T01DW9DLB2A",
            "name": "nfultz",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1682273441.848779",
        "parent_user_id": "U053BP20H8E",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "mwA",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I learned from the Ihaka tutorial - "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/web.archive.org\/web\/20081018224543\/https:\/\/www.stat.auckland.ac.nz\/~stat782\/downloads\/make-tutorial.pdf"
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "U053BP20H8E"
                ],
                "count": 1
            }
        ]
    },
    {
        "user": "U04Q78BBZ26",
        "type": "message",
        "ts": "1682360341.654369",
        "edited": {
            "user": "U04Q78BBZ26",
            "ts": "1682360381.000000"
        },
        "client_msg_id": "d2173d76-09e2-45e0-9e4a-07a41f048922",
        "text": "quick question I’m having issues with finding an answer to in the code and online:\n\nWhere is the code for `[.matrix` or `[.array`? Or rather, where are the methods that define what R does when something like `matrix(1:2)[1]` is called? I’m trying to figure out how R tells the difference between `x[1]`  and `x[1,]` when `x` is an object of class `matrix` . `traceback` is not super helpful, and I haven’t had any luck locating the methods in the source code.",
        "team": "T01DW9DLB2A",
        "user_team": "T01DW9DLB2A",
        "source_team": "T01DW9DLB2A",
        "user_profile": {
            "avatar_hash": "c2d032000a7c",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-02-20\/4828838605221_c2d032000a7cf6eb9df0_72.png",
            "first_name": "Aidan",
            "real_name": "Aidan Lakshman",
            "display_name": "Aidan Lakshman",
            "team": "T01DW9DLB2A",
            "name": "ahl27",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1682360341.654369",
        "reply_count": 2,
        "reply_users_count": 2,
        "latest_reply": "1682361543.812309",
        "reply_users": [
            "U02K6E32EP2",
            "U04Q78BBZ26"
        ],
        "replies": [
            {
                "user": "U02K6E32EP2",
                "ts": "1682361452.152269"
            },
            {
                "user": "U04Q78BBZ26",
                "ts": "1682361543.812309"
            }
        ],
        "is_locked": false,
        "subscribed": false,
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "4SfLH",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "quick question I’m having issues with finding an answer to in the code and online:\n\nWhere is the code for "
                            },
                            {
                                "type": "text",
                                "text": "[.matrix",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " or "
                            },
                            {
                                "type": "text",
                                "text": "[.array",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "? Or rather, where are the methods that define what R does when something like "
                            },
                            {
                                "type": "text",
                                "text": "matrix(1:2)[1]",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " is called? I’m trying to figure out how R tells the difference between "
                            },
                            {
                                "type": "text",
                                "text": "x[1]",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "  and "
                            },
                            {
                                "type": "text",
                                "text": "x[1,]",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " when "
                            },
                            {
                                "type": "text",
                                "text": "x",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " is an object of class "
                            },
                            {
                                "type": "text",
                                "text": "matrix",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " . "
                            },
                            {
                                "type": "text",
                                "text": "traceback",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " is not super helpful, and I haven’t had any luck locating the methods in the source code."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U02K6E32EP2",
        "type": "message",
        "ts": "1682361452.152269",
        "client_msg_id": "6a7ae52b-4ec6-48ee-a79c-73108982c14c",
        "text": "Hi Aidan, it looks like it is implemented in C : <https:\/\/github.com\/wch\/r-source\/blob\/602b79d3ed05c37da4d3cbc46d679e016c14365d\/src\/main\/subset.c> see lines &gt;= 677",
        "team": "T01DW9DLB2A",
        "user_team": "T01DW9DLB2A",
        "source_team": "T01DW9DLB2A",
        "user_profile": {
            "avatar_hash": "9ef47ae5c67d",
            "image_72": "https:\/\/avatars.slack-edge.com\/2021-10-20\/2631025401796_9ef47ae5c67d9b10ac9c_72.png",
            "first_name": "Marcel",
            "real_name": "Marcel Ramos",
            "display_name": "Marcel Ramos",
            "team": "T01DW9DLB2A",
            "name": "marcel.ramos",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1682360341.654369",
        "parent_user_id": "U04Q78BBZ26",
        "attachments": [
            {
                "id": 1,
                "footer_icon": "https:\/\/slack.github.com\/static\/img\/favicon-neutral.png",
                "color": "24292f",
                "bot_id": "B01V53YD4FJ",
                "app_unfurl_url": "https:\/\/github.com\/wch\/r-source\/blob\/602b79d3ed05c37da4d3cbc46d679e016c14365d\/src\/main\/subset.c",
                "is_app_unfurl": true,
                "app_id": "A01BP7R4KNY",
                "fallback": "<https:\/\/github.com\/wch\/r-source\/blob\/602b79d3ed05c37da4d3cbc46d679e016c14365d\/src\/main\/subset.c | subset.c>",
                "text": "```\n\/*\n *  R : A Computer Language for Statistical Data Analysis\n *  Copyright (C) 1997--2023  The R Core Team\n *  Copyright (C) 1995, 1996  Robert Gentleman and Ross Ihaka\n *\n *  This program is free software; you can redistribute it and\/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this program; if not, a copy is available at\n *  <https:\/\/www.R-project.org\/Licenses\/>\n *\n *\n *  Vector and List Subsetting\n *\n *  There are three kinds of subscripting [, [[, and $.\n *  We have three different functions to compute these.\n *\n *\n *  Note on Matrix Subscripts\n *\n *  The special [ subscripting where dim(x) == ncol(subscript matrix)\n *  is handled inside VectorSubset. The subscript matrix is turned\n *  into a subscript vector of the appropriate size and then\n *  VectorSubset continues.  This provides coherence especially\n *  regarding attributes etc. (it would be quicker to handle this case\n *  separately, but then we would have more to keep in step.\n *\/\n\n#ifdef HAVE_CONFIG_H\n#include <config.h>\n#endif\n\n#include <Defn.h>\n#include <Internal.h>\n\n\/* JMC convinced MM that this was not a good idea: *\/\n#undef _S4_subsettable\n\n\nstatic R_INLINE SEXP VECTOR_ELT_FIX_NAMED(SEXP y, R_xlen_t i) {\n    \/* if RHS (container or element) has NAMED > 0 set NAMED = NAMEDMAX.\n       Duplicating might be safer\/more consistent (fix bug reported by\n       Radford Neal; similar to PR15098) *\/\n    SEXP val = VECTOR_ELT(y, i);\n    if ((NAMED(y) || NAMED(val)))\n\tENSURE_NAMEDMAX(val);\n    return val;\n}\n\n\/* ExtractSubset allocates \"result\" and does the transfer of elements\n   from \"x\" to \"result\" according to the integer\/real subscripts given\n   in \"indx\".\n\n   The EXTRACT_SUBSET_LOOP macro allows the branches based on index\n   type and vector type to happen outside the loop.\n\n   This could avoid using data pointers, but there is little point as\n   currently the subscript code forces allocation.\n*\/\n\n#define EXTRACT_SUBSET_LOOP(STDCODE, NACODE) do { \\\n\tif (TYPEOF(indx) == INTSXP) {\t\t  \\\n\t    const int *pindx = INTEGER_RO(indx);  \\\n\t    for (i = 0; i < n; i++) {\t\t  \\\n\t\tii = pindx[i];\t\t\t  \\\n\t\tif (0 < ii && ii <= nx) {\t  \\\n\t\t    ii--;\t\t\t  \\\n\t\t    STDCODE;\t\t\t  \\\n\t\t}\t\t\t\t  \\\n\t\telse \/* out of bounds or NA *\/\t  \\\n\t\t    NACODE;\t\t\t  \\\n\t    }\t\t\t\t\t  \\\n\t}\t\t\t\t\t  \\\n\telse {\t\t\t\t\t  \\\n\t    const double *pindx = REAL_RO(indx);  \\\n\t    for (i = 0; i < n; i++) {\t\t  \\\n\t\tdouble di = pindx[i];\t\t  \\\n\t\tii = (R_xlen_t) (di - 1);\t  \\\n\t\tif (R_FINITE(di) &&\t\t  \\\n\t\t    0 <= ii && ii < nx)\t\t  \\\n\t\t    STDCODE;\t\t\t  \\\n\t\telse\t\t\t\t  \\\n\t\t    NACODE;\t\t\t  \\\n\t    }\t\t\t\t\t  \\\n\t}\t\t\t\t\t  \\\n    } while (0)\n\nNORET static void errorcallNotSubsettable(SEXP x, SEXP call)\n{\n    SEXP cond = R_makeNotSubsettableError(x, call);\n    PROTECT(cond);\n    R_signalErrorCondition(cond, call);\n    UNPROTECT(1); \/* cond; not reached *\/\n}\n\nNORET static void errorcallMissingSubs(SEXP x, SEXP call)\n{\n    if (call == R_NilValue)\n\tcall = R_CurrentExpression;\n    SEXP cond = R_makeMissingSubscriptError(x, call);\n    PROTECT(cond);\n    R_signalErrorCondition(cond, call);\n    UNPROTECT(1); \/* cond; not reached *\/\n}\n\n\nattribute_hidden SEXP ExtractSubset(SEXP x, SEXP indx, SEXP call)\n{\n    if (x == R_NilValue)\n\treturn x;\n\n    SEXP result;\n\n    if (ALTREP(x)) {\n\tresult = ALTVEC_EXTRACT_SUBSET(x, indx, call);\n\tif (result != NULL)\n\t    return result;\n    }\n\n    R_xlen_t i, ii, n, nx;\n    n = XLENGTH(indx);\n    nx = xlength(x);\n    int mode = TYPEOF(x);\n\n    \/* protect allocation in case _ELT operations need to allocate *\/\n    PROTECT(result = allocVector(mode, n));\n    switch(mode) {\n    case LGLSXP:\n\tEXTRACT_SUBSET_LOOP(LOGICAL0(result)[i] = LOGICAL_ELT(x, ii),\n\t\t\t    LOGICAL0(result)[i] = NA_INTEGER);\n\tbreak;\n    case INTSXP:\n\tEXTRACT_SUBSET_LOOP(INTEGER0(result)[i] = INTEGER_ELT(x, ii),\n\t\t\t    INTEGER0(result)[i] = NA_INTEGER);\n\tbreak;\n    case REALSXP:\n\tEXTRACT_SUBSET_LOOP(REAL0(result)[i] = REAL_ELT(x, ii),\n\t\t\t    REAL0(result)[i] = NA_REAL);\n\tbreak;\n    case CPLXSXP:\n\t{\n\t    Rcomplex NA_CPLX = { .r = NA_REAL, .i = NA_REAL };\n\t    EXTRACT_SUBSET_LOOP(COMPLEX0(result)[i] = COMPLEX_ELT(x, ii),\n\t\t\t\tCOMPLEX0(result)[i] = NA_CPLX);\n\t}\n\tbreak;\n    case STRSXP:\n\tEXTRACT_SUBSET_LOOP(SET_STRING_ELT(result, i, STRING_ELT(x, ii)),\n\t\t\t    SET_STRING_ELT(result, i, NA_STRING));\n\tbreak;\n    case VECSXP:\n    case EXPRSXP:\n\tEXTRACT_SUBSET_LOOP(SET_VECTOR_ELT(result, i,\n\t\t\t\t\t   VECTOR_ELT_FIX_NAMED(x, ii)),\n\t\t\t    SET_VECTOR_ELT(result, i, R_NilValue));\n\tbreak;\n    case RAWSXP:\n\tEXTRACT_SUBSET_LOOP(RAW0(result)[i] = RAW_ELT(x, ii),\n\t\t\t    RAW0(result)[i] = (Rbyte) 0);\n\tbreak;\n    case LISTSXP:\n\t\/* cannot happen: pairlists are coerced to lists *\/\n    case LANGSXP:\n\t\/* cannot happen: LANGSXPs are coerced to lists *\/\n    default:\n\terrorcallNotSubsettable(x, call);\n    }\n    UNPROTECT(1); \/* result *\/\n    return result;\n}\n\n\n\/* This is for all cases with a single index, including 1D arrays and\n   matrix indexing of arrays *\/\nstatic SEXP VectorSubset(SEXP x, SEXP s, SEXP call)\n{\n    if (s == R_MissingArg) return duplicate(x);\n\n    \/* Check to see if we have special matrix subscripting. *\/\n    \/* If we do, make a real subscript vector and protect it. *\/\n\n    PROTECT(s);\n    if (ATTRIB(s) != R_NilValue) { \/* pretest to speed up simple case *\/\n\tSEXP dim = getAttrib(x, R_DimSymbol);\n\tif (isMatrix(s) && isArray(x) && ncols(s) == length(dim)) {\n\t    if (isString(s)) {\n\t\tSEXP dnames = PROTECT(GetArrayDimnames(x));\n \t\ts = strmat2intmat(s, dnames, call, x);\n\t\tUNPROTECT(2); \/* dnames, s *\/\n\t\tPROTECT(s);\n\t    }\n\t    if (isInteger(s) || isReal(s)) {\n\t\ts = mat2indsub(dim, s, call, x);\n\t\tUNPROTECT(1);\n\t\tPROTECT(s);\n\t    }\n\t}\n    }\n\n    \/* Convert to a vector of integer subscripts *\/\n    \/* in the range 1:length(x). *\/\n    R_xlen_t stretch = 1;\n    SEXP indx = PROTECT(makeSubscript(x, s, &stretch, call));\n\n    \/* Allocate the result. *\/\n\n    int mode = TYPEOF(x);\n    SEXP result = PROTECT(ExtractSubset(x, indx, call));\n    if (mode == VECSXP || mode == EXPRSXP)\n\t\/* we do not duplicate the values when extracting the subset,\n\t   so to be conservative mark the result as NAMED = NAMEDMAX *\/\n\tENSURE_NAMEDMAX(result);\n\n    if (result != R_NilValue) {\n\tSEXP attrib, nattrib;\n\tif (\n\t    ((attrib = getAttrib(x, R_NamesSymbol)) != R_NilValue) ||\n\t    ( \/* here we might have an array.  Use row names if 1D *\/\n\t\tisArray(x) && length(getAttrib(x, R_DimNamesSymbol)) == 1 &&\n\t\t(attrib = getAttrib(x, R_DimNamesSymbol)) != R_NilValue &&\n\t\t(attrib = GetRowNames(attrib)) != R_NilValue\n\t\t)\n\t    ) {\n\t    PROTECT(attrib);\n\t    PROTECT(nattrib = ExtractSubset(attrib, indx, call));\n\t    setAttrib(result, R_NamesSymbol, nattrib);\n\t    UNPROTECT(2); \/* attrib, nattrib *\/\n\t}\n\tif ((attrib = getAttrib(x, R_SrcrefSymbol)) != R_NilValue &&\n\t    TYPEOF(attrib) == VECSXP) {\n\t    PROTECT(nattrib = ExtractSubset(attrib, indx, call));\n\t    setAttrib(result, R_SrcrefSymbol, nattrib);\n\t    UNPROTECT(1);\n\t}\n\t\/* FIXME:  this is wrong, because the slots are gone, so result is an invalid object of the S4 class! JMC 3\/3\/09 *\/\n#ifdef _S4_subsettable\n\tif(IS_S4_OBJECT(x)) { \/* e.g. contains = \"list\" *\/\n\t    setAttrib(result, R_ClassSymbol, getAttrib(x, R_ClassSymbol));\n\t    SET_S4_OBJECT(result);\n\t}\n#endif\n    }\n    UNPROTECT(3);\n    return result;\n}\n\nNORET static void errorcallOutOfBounds(SEXP x, int subscript,\n\t\t\t\t       R_xlen_t index, SEXP call)\n{\n    SEXP sindex = ScalarReal((double) index);\n    PROTECT(sindex);\n    SEXP cond = R_makeOutOfBoundsError(x, subscript, sindex, call, NULL);\n    PROTECT(cond);\n    R_signalErrorCondition(cond, call);\n    UNPROTECT(2); \/…",
                "title": "<https:\/\/github.com\/wch\/r-source\/blob\/602b79d3ed05c37da4d3cbc46d679e016c14365d\/src\/main\/subset.c | subset.c>",
                "footer": "<https:\/\/github.com\/wch\/r-source|wch\/r-source>",
                "mrkdwn_in": [
                    "text"
                ]
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "6Jnl",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Hi Aidan, it looks like it is implemented in C : "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/github.com\/wch\/r-source\/blob\/602b79d3ed05c37da4d3cbc46d679e016c14365d\/src\/main\/subset.c"
                            },
                            {
                                "type": "text",
                                "text": " see lines >= 677"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "user": "U04Q78BBZ26",
        "type": "message",
        "ts": "1682361543.812309",
        "client_msg_id": "165c88c0-7f8a-455d-ae0e-e6c2ed547094",
        "text": "ah incredible, thank you!",
        "team": "T01DW9DLB2A",
        "user_team": "T01DW9DLB2A",
        "source_team": "T01DW9DLB2A",
        "user_profile": {
            "avatar_hash": "c2d032000a7c",
            "image_72": "https:\/\/avatars.slack-edge.com\/2023-02-20\/4828838605221_c2d032000a7cf6eb9df0_72.png",
            "first_name": "Aidan",
            "real_name": "Aidan Lakshman",
            "display_name": "Aidan Lakshman",
            "team": "T01DW9DLB2A",
            "name": "ahl27",
            "is_restricted": false,
            "is_ultra_restricted": false
        },
        "thread_ts": "1682360341.654369",
        "parent_user_id": "U04Q78BBZ26",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "3S9NF",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "ah incredible, thank you!"
                            }
                        ]
                    }
                ]
            }
        ]
    }
]